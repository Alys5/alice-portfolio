---
description: Scroll-Triggered Animations & Parallax Effects 2025
globs: 
alwaysApply: false
---
# Scroll-Triggered Animations & Parallax Effects 2025

## Intersection Observer Composable

### useScrollAnimation
```typescript
// useScrollAnimation.ts
import { ref, onMounted, onUnmounted, type Ref } from 'vue'

interface ScrollAnimationOptions {
  threshold?: number | number[]
  rootMargin?: string
  triggerOnce?: boolean
  staggerDelay?: number
}

export function useScrollAnimation(
  target: Ref<HTMLElement | null>,
  options: ScrollAnimationOptions = {}
) {
  const isVisible = ref(false)
  const hasTriggered = ref(false)
  const animationDelay = ref(0)
  
  const {
    threshold = 0.2,
    rootMargin = '0px',
    triggerOnce = true,
    staggerDelay = 0
  } = options

  onMounted(() => {
    if (!target.value || !('IntersectionObserver' in window)) return

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          isVisible.value = true
          if (triggerOnce) {
            hasTriggered.value = true
            observer.disconnect()
          }
        } else if (!triggerOnce) {
          isVisible.value = false
        }
      },
      { threshold, rootMargin }
    )

    observer.observe(target.value)

    onUnmounted(() => observer.disconnect())
  })

  return {
    isVisible: readonly(isVisible),
    hasTriggered: readonly(hasTriggered),
    animationDelay: readonly(animationDelay)
  }
}
```

### useParallax
```typescript
// useParallax.ts
import { ref, onMounted, onUnmounted } from 'vue'

interface ParallaxOptions {
  speed?: number
  direction?: 'vertical' | 'horizontal'
  easing?: 'linear' | 'ease-out' | 'ease-in-out'
}

export function useParallax(
  target: Ref<HTMLElement | null>,
  options: ParallaxOptions = {}
) {
  const { speed = 0.5, direction = 'vertical', easing = 'linear' } = options
  const transform = ref('')
  
  let ticking = false

  const updateParallax = () => {
    if (!target.value) return
    
    const scrolled = window.pageYOffset
    const rate = scrolled * speed
    
    if (direction === 'vertical') {
      transform.value = `translateY(${rate}px)`
    } else {
      transform.value = `translateX(${rate}px)`
    }
    
    target.value.style.transform = transform.value
    ticking = false
  }

  const handleScroll = () => {
    if (!ticking) {
      requestAnimationFrame(updateParallax)
      ticking = true
    }
  }

  onMounted(() => {
    window.addEventListener('scroll', handleScroll, { passive: true })
  })

  onUnmounted(() => {
    window.removeEventListener('scroll', handleScroll)
  })

  return { transform: readonly(transform) }
}
```

## Scroll-Triggered Animation Components

### AnimatedSection Component
```vue
<template>
  <section 
    ref="sectionRef"
    class="animated-section"
    :class="[
      `animated-section--${variant}`,
      { 'animated-section--visible': isVisible }
    ]"
  >
    <div class="animated-section__content">
      <slot />
    </div>
    <div 
      v-if="showParallax"
      ref="parallaxRef"
      class="animated-section__parallax"
    />
  </section>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useScrollAnimation } from '@/composables/useScrollAnimation'
import { useParallax } from '@/composables/useParallax'

interface Props {
  variant?: 'fade-up' | 'fade-in' | 'slide-left' | 'slide-right' | 'scale'
  showParallax?: boolean
  parallaxSpeed?: number
  threshold?: number
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'fade-up',
  showParallax: false,
  parallaxSpeed: 0.3,
  threshold: 0.2
})

const sectionRef = ref<HTMLElement>()
const parallaxRef = ref<HTMLElement>()

const { isVisible } = useScrollAnimation(sectionRef, {
  threshold: props.threshold,
  triggerOnce: true
})

const { transform } = useParallax(parallaxRef, {
  speed: props.parallaxSpeed
})
</script>

<style scoped lang="scss">
.animated-section {
  position: relative;
  overflow: hidden;
  
  &__content {
    position: relative;
    z-index: 2;
  }
  
  &__parallax {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--gradient-primary);
    opacity: 0.1;
    z-index: 1;
  }
  
  // Animation variants
  &--fade-up {
    opacity: 0;
    transform: translateY(50px);
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    
    &.animated-section--visible {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  &--fade-in {
    opacity: 0;
    transition: opacity 0.6s ease-out;
    
    &.animated-section--visible {
      opacity: 1;
    }
  }
  
  &--slide-left {
    opacity: 0;
    transform: translateX(-50px);
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    
    &.animated-section--visible {
      opacity: 1;
      transform: translateX(0);
    }
  }
  
  &--slide-right {
    opacity: 0;
    transform: translateX(50px);
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    
    &.animated-section--visible {
      opacity: 1;
      transform: translateX(0);
    }
  }
  
  &--scale {
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    
    &.animated-section--visible {
      opacity: 1;
      transform: scale(1);
    }
  }
}

// Reduced motion
@media (prefers-reduced-motion: reduce) {
  .animated-section {
    transition: none !important;
    
    &.animated-section--visible {
      opacity: 1;
      transform: none;
    }
  }
}
</style>
```

## Staggered Animations

### StaggeredList Component
```vue
<template>
  <div ref="containerRef" class="staggered-list">
    <div 
      v-for="(item, index) in items" 
      :key="item.id"
      class="staggered-item"
      :class="[
        `staggered-item--${animation}`,
        { 'staggered-item--visible': isVisible }
      ]"
      :style="{ '--stagger-delay': `${index * staggerDelay}ms` }"
    >
      <slot name="item" :item="item" :index="index" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useScrollAnimation } from '@/composables/useScrollAnimation'

interface Props {
  items: any[]
  animation?: 'fade-up' | 'fade-in' | 'slide-up' | 'scale'
  staggerDelay?: number
  threshold?: number
}

const props = withDefaults(defineProps<Props>(), {
  animation: 'fade-up',
  staggerDelay: 100,
  threshold: 0.1
})

const containerRef = ref<HTMLElement>()

const { isVisible } = useScrollAnimation(containerRef, {
  threshold: props.threshold,
  triggerOnce: true
})
</script>

<style scoped lang="scss">
.staggered-list {
  display: grid;
  gap: var(--spacing-lg);
  
  @media (min-width: 768px) {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }
}

.staggered-item {
  opacity: 0;
  transform: translateY(30px);
  transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  transition-delay: var(--stagger-delay);
  
  &--visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  // Animation variants
  &--fade-in {
    transform: none;
  }
  
  &--slide-up {
    transform: translateY(50px);
  }
  
  &--scale {
    transform: scale(0.8);
    
    &.staggered-item--visible {
      transform: scale(1);
    }
  }
}

// Reduced motion
@media (prefers-reduced-motion: reduce) {
  .staggered-item {
    transition: none !important;
    transition-delay: 0ms !important;
    
    &.staggered-item--visible {
      opacity: 1;
      transform: none;
    }
  }
}
</style>
```

## Parallax Backgrounds

### ParallaxBackground Component
```vue
<template>
  <div class="parallax-background">
    <div 
      ref="backgroundRef"
      class="parallax-background__layer"
      :style="{ backgroundImage: `url(${background})` }"
    />
    <div class="parallax-background__content">
      <slot />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useParallax } from '@/composables/useParallax'

interface Props {
  background: string
  speed?: number
  direction?: 'vertical' | 'horizontal'
}

const props = withDefaults(defineProps<Props>(), {
  speed: 0.5,
  direction: 'vertical'
})

const backgroundRef = ref<HTMLElement>()

useParallax(backgroundRef, {
  speed: props.speed,
  direction: props.direction
})
</script>

<style scoped lang="scss">
.parallax-background {
  position: relative;
  overflow: hidden;
  min-height: 100vh;
  
  &__layer {
    position: absolute;
    top: -20%;
    left: -20%;
    right: -20%;
    bottom: -20%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 1;
  }
  
  &__content {
    position: relative;
    z-index: 2;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}
</style>
```

## Scroll Progress Indicator

### ScrollProgress Component
```vue
<template>
  <div class="scroll-progress">
    <div 
      class="scroll-progress__bar"
      :style="{ width: `${progress}%` }"
    />
    <div class="scroll-progress__indicator">
      {{ Math.round(progress) }}%
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'

const progress = ref(0)

const updateProgress = () => {
  const scrollTop = window.pageYOffset
  const docHeight = document.documentElement.scrollHeight - window.innerHeight
  progress.value = (scrollTop / docHeight) * 100
}

onMounted(() => {
  window.addEventListener('scroll', updateProgress, { passive: true })
  updateProgress()
})

onUnmounted(() => {
  window.removeEventListener('scroll', updateProgress)
})
</script>

<style scoped lang="scss">
.scroll-progress {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  z-index: 1000;
  
  &__bar {
    height: 100%;
    background: var(--gradient-primary);
    transition: width 0.1s ease;
  }
  
  &__indicator {
    position: absolute;
    top: 8px;
    right: 16px;
    font-size: 12px;
    color: var(--ebony-clay);
    background: rgba(255, 255, 255, 0.9);
    padding: 4px 8px;
    border-radius: 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  &:hover .scroll-progress__indicator {
    opacity: 1;
  }
}
</style>
```

## Performance Optimizations

### Debounced Scroll Handler
```typescript
// useDebouncedScroll.ts
import { ref, onMounted, onUnmounted } from 'vue'

export function useDebouncedScroll(delay = 16) {
  const scrollY = ref(0)
  const scrollX = ref(0)
  let timeoutId: number

  const handleScroll = () => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => {
      scrollY.value = window.pageYOffset
      scrollX.value = window.pageXOffset
    }, delay)
  }

  onMounted(() => {
    window.addEventListener('scroll', handleScroll, { passive: true })
  })

  onUnmounted(() => {
    window.removeEventListener('scroll', handleScroll)
    clearTimeout(timeoutId)
  })

  return {
    scrollY: readonly(scrollY),
    scrollX: readonly(scrollX)
  }
}
```

### Lazy Animation Loading
```vue
<template>
  <div ref="containerRef">
    <AnimatedSection 
      v-if="shouldLoad"
      :variant="animationVariant"
    >
      <slot />
    </AnimatedSection>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useScrollAnimation } from '@/composables/useScrollAnimation'

const containerRef = ref<HTMLElement>()
const shouldLoad = ref(false)

const { isVisible } = useScrollAnimation(containerRef, {
  threshold: 0.1,
  triggerOnce: true
})

// Load animation when container is visible
watch(isVisible, (visible) => {
  if (visible) {
    shouldLoad.value = true
  }
})
</script>
```

## Rimandi

- [useScrollAnimation.ts](mdc:src/composables/useScrollAnimation.ts)
- [useParallax.ts](mdc:src/composables/useParallax.ts)
- [AnimatedSection.vue](mdc:src/components/sections/AnimatedSection.vue)
- [StaggeredList.vue](mdc:src/components/ui/StaggeredList.vue)
- [ParallaxBackground.vue](mdc:src/components/ui/ParallaxBackground.vue)
- [ScrollProgress.vue](mdc:src/components/ui/ScrollProgress.vue)
- [animations.scss](mdc:src/styles/animations.scss)

